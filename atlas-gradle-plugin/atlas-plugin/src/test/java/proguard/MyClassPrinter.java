/*
 *
 *
 *
 *                                   Apache License
 *                             Version 2.0, January 2004
 *                          http://www.apache.org/licenses/
 *
 *     TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION
 *
 *     1. Definitions.
 *
 *        "License" shall mean the terms and conditions for use, reproduction,
 *        and distribution as defined by Sections 1 through 9 of this document.
 *
 *        "Licensor" shall mean the copyright owner or entity authorized by
 *        the copyright owner that is granting the License.
 *
 *        "Legal Entity" shall mean the union of the acting entity and all
 *        other entities that control, are controlled by, or are under common
 *        control with that entity. For the purposes of this definition,
 *        "control" means (i) the power, direct or indirect, to cause the
 *        direction or management of such entity, whether by contract or
 *        otherwise, or (ii) ownership of fifty percent (50%) or more of the
 *        outstanding shares, or (iii) beneficial ownership of such entity.
 *
 *        "You" (or "Your") shall mean an individual or Legal Entity
 *        exercising permissions granted by this License.
 *
 *        "Source" form shall mean the preferred form for making modifications,
 *        including but not limited to software source code, documentation
 *        source, and configuration files.
 *
 *        "Object" form shall mean any form resulting from mechanical
 *        transformation or translation of a Source form, including but
 *        not limited to compiled object code, generated documentation,
 *        and conversions to other media types.
 *
 *        "Work" shall mean the work of authorship, whether in Source or
 *        Object form, made available under the License, as indicated by a
 *        copyright notice that is included in or attached to the work
 *        (an example is provided in the Appendix below).
 *
 *        "Derivative Works" shall mean any work, whether in Source or Object
 *        form, that is based on (or derived from) the Work and for which the
 *        editorial revisions, annotations, elaborations, or other modifications
 *        represent, as a whole, an original work of authorship. For the purposes
 *        of this License, Derivative Works shall not include works that remain
 *        separable from, or merely link (or bind by name) to the interfaces of,
 *        the Work and Derivative Works thereof.
 *
 *        "Contribution" shall mean any work of authorship, including
 *        the original version of the Work and any modifications or additions
 *        to that Work or Derivative Works thereof, that is intentionally
 *        submitted to Licensor for inclusion in the Work by the copyright owner
 *        or by an individual or Legal Entity authorized to submit on behalf of
 *        the copyright owner. For the purposes of this definition, "submitted"
 *        means any form of electronic, verbal, or written communication sent
 *        to the Licensor or its representatives, including but not limited to
 *        communication on electronic mailing lists, source code control systems,
 *        and issue tracking systems that are managed by, or on behalf of, the
 *        Licensor for the purpose of discussing and improving the Work, but
 *        excluding communication that is conspicuously marked or otherwise
 *        designated in writing by the copyright owner as "Not a Contribution."
 *
 *        "Contributor" shall mean Licensor and any individual or Legal Entity
 *        on behalf of whom a Contribution has been received by Licensor and
 *        subsequently incorporated within the Work.
 *
 *     2. Grant of Copyright License. Subject to the terms and conditions of
 *        this License, each Contributor hereby grants to You a perpetual,
 *        worldwide, non-exclusive, no-charge, royalty-free, irrevocable
 *        copyright license to reproduce, prepare Derivative Works of,
 *        publicly display, publicly perform, sublicense, and distribute the
 *        Work and such Derivative Works in Source or Object form.
 *
 *     3. Grant of Patent License. Subject to the terms and conditions of
 *        this License, each Contributor hereby grants to You a perpetual,
 *        worldwide, non-exclusive, no-charge, royalty-free, irrevocable
 *        (except as stated in this section) patent license to make, have made,
 *        use, offer to sell, sell, import, and otherwise transfer the Work,
 *        where such license applies only to those patent claims licensable
 *        by such Contributor that are necessarily infringed by their
 *        Contribution(s) alone or by combination of their Contribution(s)
 *        with the Work to which such Contribution(s) was submitted. If You
 *        institute patent litigation against any entity (including a
 *        cross-claim or counterclaim in a lawsuit) alleging that the Work
 *        or a Contribution incorporated within the Work constitutes direct
 *        or contributory patent infringement, then any patent licenses
 *        granted to You under this License for that Work shall terminate
 *        as of the date such litigation is filed.
 *
 *     4. Redistribution. You may reproduce and distribute copies of the
 *        Work or Derivative Works thereof in any medium, with or without
 *        modifications, and in Source or Object form, provided that You
 *        meet the following conditions:
 *
 *        (a) You must give any other recipients of the Work or
 *            Derivative Works a copy of this License; and
 *
 *        (b) You must cause any modified files to carry prominent notices
 *            stating that You changed the files; and
 *
 *        (c) You must retain, in the Source form of any Derivative Works
 *            that You distribute, all copyright, patent, trademark, and
 *            attribution notices from the Source form of the Work,
 *            excluding those notices that do not pertain to any part of
 *            the Derivative Works; and
 *
 *        (d) If the Work includes a "NOTICE" text file as part of its
 *            distribution, then any Derivative Works that You distribute must
 *            include a readable copy of the attribution notices contained
 *            within such NOTICE file, excluding those notices that do not
 *            pertain to any part of the Derivative Works, in at least one
 *            of the following places: within a NOTICE text file distributed
 *            as part of the Derivative Works; within the Source form or
 *            documentation, if provided along with the Derivative Works; or,
 *            within a display generated by the Derivative Works, if and
 *            wherever such third-party notices normally appear. The contents
 *            of the NOTICE file are for informational purposes only and
 *            do not modify the License. You may add Your own attribution
 *            notices within Derivative Works that You distribute, alongside
 *            or as an addendum to the NOTICE text from the Work, provided
 *            that such additional attribution notices cannot be construed
 *            as modifying the License.
 *
 *        You may add Your own copyright statement to Your modifications and
 *        may provide additional or different license terms and conditions
 *        for use, reproduction, or distribution of Your modifications, or
 *        for any such Derivative Works as a whole, provided Your use,
 *        reproduction, and distribution of the Work otherwise complies with
 *        the conditions stated in this License.
 *
 *     5. Submission of Contributions. Unless You explicitly state otherwise,
 *        any Contribution intentionally submitted for inclusion in the Work
 *        by You to the Licensor shall be under the terms and conditions of
 *        this License, without any additional terms or conditions.
 *        Notwithstanding the above, nothing herein shall supersede or modify
 *        the terms of any separate license agreement you may have executed
 *        with Licensor regarding such Contributions.
 *
 *     6. Trademarks. This License does not grant permission to use the trade
 *        names, trademarks, service marks, or product names of the Licensor,
 *        except as required for reasonable and customary use in describing the
 *        origin of the Work and reproducing the content of the NOTICE file.
 *
 *     7. Disclaimer of Warranty. Unless required by applicable law or
 *        agreed to in writing, Licensor provides the Work (and each
 *        Contributor provides its Contributions) on an "AS IS" BASIS,
 *        WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
 *        implied, including, without limitation, any warranties or conditions
 *        of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A
 *        PARTICULAR PURPOSE. You are solely responsible for determining the
 *        appropriateness of using or redistributing the Work and assume any
 *        risks associated with Your exercise of permissions under this License.
 *
 *     8. Limitation of Liability. In no event and under no legal theory,
 *        whether in tort (including negligence), contract, or otherwise,
 *        unless required by applicable law (such as deliberate and grossly
 *        negligent acts) or agreed to in writing, shall any Contributor be
 *        liable to You for damages, including any direct, indirect, special,
 *        incidental, or consequential damages of any character arising as a
 *        result of this License or out of the use or inability to use the
 *        Work (including but not limited to damages for loss of goodwill,
 *        work stoppage, computer failure or malfunction, or any and all
 *        other commercial damages or losses), even if such Contributor
 *        has been advised of the possibility of such damages.
 *
 *     9. Accepting Warranty or Additional Liability. While redistributing
 *        the Work or Derivative Works thereof, You may choose to offer,
 *        and charge a fee for, acceptance of support, warranty, indemnity,
 *        or other liability obligations and/or rights consistent with this
 *        License. However, in accepting such obligations, You may act only
 *        on Your own behalf and on Your sole responsibility, not on behalf
 *        of any other Contributor, and only if You agree to indemnify,
 *        defend, and hold each Contributor harmless for any liability
 *        incurred by, or claims asserted against, such Contributor by reason
 *        of your accepting any such warranty or additional liability.
 *
 *     END OF TERMS AND CONDITIONS
 *
 *     APPENDIX: How to apply the Apache License to your work.
 *
 *        To apply the Apache License to your work, attach the following
 *        boilerplate notice, with the fields enclosed by brackets "[]"
 *        replaced with your own identifying information. (Don't include
 *        the brackets!)  The text should be enclosed in the appropriate
 *        comment syntax for the file format. We also recommend that a
 *        file or class name and description of purpose be included on the
 *        same "printed page" as the copyright notice for easier
 *        identification within third-party archives.
 *
 *     Copyright 2016 Alibaba Group
 *
 *     Licensed under the Apache License, Version 2.0 (the "License");
 *     you may not use this file except in compliance with the License.
 *     You may obtain a copy of the License at
 *
 *         http://www.apache.org/licenses/LICENSE-2.0
 *
 *     Unless required by applicable law or agreed to in writing, software
 *     distributed under the License is distributed on an "AS IS" BASIS,
 *     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *     See the License for the specific language governing permissions and
 *     limitations under the License.
 *
 *
 */
package proguard;

import java.io.PrintStream;

import proguard.classfile.ClassConstants;
import proguard.classfile.Clazz;
import proguard.classfile.Field;
import proguard.classfile.LibraryClass;
import proguard.classfile.LibraryField;
import proguard.classfile.LibraryMethod;
import proguard.classfile.Member;
import proguard.classfile.Method;
import proguard.classfile.ProgramClass;
import proguard.classfile.ProgramField;
import proguard.classfile.ProgramMember;
import proguard.classfile.ProgramMethod;
import proguard.classfile.VisitorAccepter;
import proguard.classfile.attribute.BootstrapMethodInfo;
import proguard.classfile.attribute.BootstrapMethodsAttribute;
import proguard.classfile.attribute.CodeAttribute;
import proguard.classfile.attribute.ConstantValueAttribute;
import proguard.classfile.attribute.DeprecatedAttribute;
import proguard.classfile.attribute.EnclosingMethodAttribute;
import proguard.classfile.attribute.ExceptionInfo;
import proguard.classfile.attribute.ExceptionsAttribute;
import proguard.classfile.attribute.InnerClassesAttribute;
import proguard.classfile.attribute.InnerClassesInfo;
import proguard.classfile.attribute.LineNumberInfo;
import proguard.classfile.attribute.LineNumberTableAttribute;
import proguard.classfile.attribute.LocalVariableInfo;
import proguard.classfile.attribute.LocalVariableTableAttribute;
import proguard.classfile.attribute.LocalVariableTypeInfo;
import proguard.classfile.attribute.LocalVariableTypeTableAttribute;
import proguard.classfile.attribute.MethodParametersAttribute;
import proguard.classfile.attribute.ParameterInfo;
import proguard.classfile.attribute.SignatureAttribute;
import proguard.classfile.attribute.SourceDirAttribute;
import proguard.classfile.attribute.SourceFileAttribute;
import proguard.classfile.attribute.SyntheticAttribute;
import proguard.classfile.attribute.UnknownAttribute;
import proguard.classfile.attribute.annotation.Annotation;
import proguard.classfile.attribute.annotation.AnnotationDefaultAttribute;
import proguard.classfile.attribute.annotation.AnnotationElementValue;
import proguard.classfile.attribute.annotation.ArrayElementValue;
import proguard.classfile.attribute.annotation.ClassElementValue;
import proguard.classfile.attribute.annotation.ConstantElementValue;
import proguard.classfile.attribute.annotation.EnumConstantElementValue;
import proguard.classfile.attribute.annotation.RuntimeInvisibleAnnotationsAttribute;
import proguard.classfile.attribute.annotation.RuntimeInvisibleParameterAnnotationsAttribute;
import proguard.classfile.attribute.annotation.RuntimeInvisibleTypeAnnotationsAttribute;
import proguard.classfile.attribute.annotation.RuntimeVisibleAnnotationsAttribute;
import proguard.classfile.attribute.annotation.RuntimeVisibleParameterAnnotationsAttribute;
import proguard.classfile.attribute.annotation.RuntimeVisibleTypeAnnotationsAttribute;
import proguard.classfile.attribute.annotation.TypeAnnotation;
import proguard.classfile.attribute.annotation.TypePathInfo;
import proguard.classfile.attribute.annotation.target.CatchTargetInfo;
import proguard.classfile.attribute.annotation.target.EmptyTargetInfo;
import proguard.classfile.attribute.annotation.target.FormalParameterTargetInfo;
import proguard.classfile.attribute.annotation.target.LocalVariableTargetElement;
import proguard.classfile.attribute.annotation.target.LocalVariableTargetInfo;
import proguard.classfile.attribute.annotation.target.OffsetTargetInfo;
import proguard.classfile.attribute.annotation.target.SuperTypeTargetInfo;
import proguard.classfile.attribute.annotation.target.ThrowsTargetInfo;
import proguard.classfile.attribute.annotation.target.TypeArgumentTargetInfo;
import proguard.classfile.attribute.annotation.target.TypeParameterBoundTargetInfo;
import proguard.classfile.attribute.annotation.target.TypeParameterTargetInfo;
import proguard.classfile.attribute.annotation.target.visitor.LocalVariableTargetElementVisitor;
import proguard.classfile.attribute.annotation.target.visitor.TargetInfoVisitor;
import proguard.classfile.attribute.annotation.visitor.AnnotationVisitor;
import proguard.classfile.attribute.annotation.visitor.ElementValueVisitor;
import proguard.classfile.attribute.annotation.visitor.TypeAnnotationVisitor;
import proguard.classfile.attribute.annotation.visitor.TypePathInfoVisitor;
import proguard.classfile.attribute.preverification.DoubleType;
import proguard.classfile.attribute.preverification.FloatType;
import proguard.classfile.attribute.preverification.FullFrame;
import proguard.classfile.attribute.preverification.IntegerType;
import proguard.classfile.attribute.preverification.LessZeroFrame;
import proguard.classfile.attribute.preverification.LongType;
import proguard.classfile.attribute.preverification.MoreZeroFrame;
import proguard.classfile.attribute.preverification.NullType;
import proguard.classfile.attribute.preverification.ObjectType;
import proguard.classfile.attribute.preverification.SameOneFrame;
import proguard.classfile.attribute.preverification.SameZeroFrame;
import proguard.classfile.attribute.preverification.StackMapAttribute;
import proguard.classfile.attribute.preverification.StackMapTableAttribute;
import proguard.classfile.attribute.preverification.TopType;
import proguard.classfile.attribute.preverification.UninitializedThisType;
import proguard.classfile.attribute.preverification.UninitializedType;
import proguard.classfile.attribute.preverification.visitor.StackMapFrameVisitor;
import proguard.classfile.attribute.preverification.visitor.VerificationTypeVisitor;
import proguard.classfile.attribute.visitor.AttributeVisitor;
import proguard.classfile.attribute.visitor.BootstrapMethodInfoVisitor;
import proguard.classfile.attribute.visitor.ExceptionInfoVisitor;
import proguard.classfile.attribute.visitor.InnerClassesInfoVisitor;
import proguard.classfile.attribute.visitor.LineNumberInfoVisitor;
import proguard.classfile.attribute.visitor.LocalVariableInfoVisitor;
import proguard.classfile.attribute.visitor.LocalVariableTypeInfoVisitor;
import proguard.classfile.attribute.visitor.ParameterInfoVisitor;
import proguard.classfile.constant.ClassConstant;
import proguard.classfile.constant.DoubleConstant;
import proguard.classfile.constant.FieldrefConstant;
import proguard.classfile.constant.FloatConstant;
import proguard.classfile.constant.IntegerConstant;
import proguard.classfile.constant.InterfaceMethodrefConstant;
import proguard.classfile.constant.InvokeDynamicConstant;
import proguard.classfile.constant.LongConstant;
import proguard.classfile.constant.MethodHandleConstant;
import proguard.classfile.constant.MethodTypeConstant;
import proguard.classfile.constant.MethodrefConstant;
import proguard.classfile.constant.NameAndTypeConstant;
import proguard.classfile.constant.StringConstant;
import proguard.classfile.constant.Utf8Constant;
import proguard.classfile.constant.visitor.ConstantVisitor;
import proguard.classfile.instruction.ConstantInstruction;
import proguard.classfile.instruction.Instruction;
import proguard.classfile.instruction.LookUpSwitchInstruction;
import proguard.classfile.instruction.TableSwitchInstruction;
import proguard.classfile.instruction.visitor.InstructionVisitor;
import proguard.classfile.util.ClassUtil;
import proguard.classfile.util.SimplifiedVisitor;
import proguard.classfile.visitor.ClassVisitor;
import proguard.classfile.visitor.MemberVisitor;


/**
 * This <code>ClassVisitor</code> prints out the complete internal
 * structure of the classes it visits.
 *
 * @author Eric Lafortune
 */
public class MyClassPrinter
extends      SimplifiedVisitor
implements ClassVisitor,
             ConstantVisitor,
    MemberVisitor,
             AttributeVisitor,
             BootstrapMethodInfoVisitor,
             InnerClassesInfoVisitor,
             ExceptionInfoVisitor,
             StackMapFrameVisitor,
             VerificationTypeVisitor,
             LineNumberInfoVisitor,
             ParameterInfoVisitor,
             LocalVariableInfoVisitor,
             LocalVariableTypeInfoVisitor,
             AnnotationVisitor,
             TypeAnnotationVisitor,
             TargetInfoVisitor,
             LocalVariableTargetElementVisitor,
             TypePathInfoVisitor,
             ElementValueVisitor,
             InstructionVisitor
{
    private static final String INDENTATION = "  ";

    private final PrintStream ps;

    private int indentation;


    /**
     * Creates a new ClassPrinter that prints to <code>System.out</code>.
     */
    public MyClassPrinter()
    {
        this(System.out);
    }


    /**
     * Creates a new ClassPrinter that prints to the given
     * <code>PrintStream</code>.
     */
    public MyClassPrinter(PrintStream printStream)
    {
        ps = printStream;
    }


    // Implementations for ClassVisitor.

    public void visitProgramClass(ProgramClass programClass)
    {
        //println("_____________________________________________________________________");
        //println(visitorInfo(programClass) + " " +
        //        "Program class: " + programClass.getName());
        //indent();
        //println("Superclass:    " + programClass.getSuperName());
        //println("Major version: 0x" + Integer.toHexString(ClassUtil.internalMajorClassVersion(programClass.u4version)));
        //println("Minor version: 0x" + Integer.toHexString(ClassUtil.internalMinorClassVersion(programClass.u4version)));
        //println("  = target " + ClassUtil.externalClassVersion(programClass.u4version));
        //println("Access flags:  0x" + Integer.toHexString(programClass.u2accessFlags));
        //println("  = " +
        //        ((programClass.u2accessFlags & ClassConstants.ACC_ANNOTATTION) != 0 ? "@ " : "") +
        //        ClassUtil.externalClassAccessFlags(programClass.u2accessFlags) +
        //        ((programClass.u2accessFlags & ClassConstants.ACC_ENUM)      != 0 ? "enum " :
        //         (programClass.u2accessFlags & ClassConstants.ACC_INTERFACE) == 0 ? "class " :
        //                                                                                     "") +
        //        ClassUtil.externalClassName(programClass.getName()) +
        //        (programClass.u2superClass == 0 ? "" : " extends " +
        //        ClassUtil.externalClassName(programClass.getSuperName())));
        //outdent();
        //println();
        //
        //println("Interfaces (count = " + programClass.u2interfacesCount + "):");
        //indent();
        //programClass.interfaceConstantsAccept(this);
        //outdent();
        //println();
        //
        //println("Constant Pool (count = " + programClass.u2constantPoolCount + "):");
        //indent();
        //programClass.constantPoolEntriesAccept(this);
        //outdent();
        //println();
        //
        //println("Fields (count = " + programClass.u2fieldsCount + "):");
        //indent();
        //programClass.fieldsAccept(this);
        //outdent();
        //println();

        println("Methods (count = " + programClass.u2methodsCount + "):");
        indent();
        programClass.methodsAccept(this);
        outdent();
        println();

        //println("Class file attributes (count = " + programClass.u2attributesCount + "):");
        //indent();
        //programClass.attributesAccept(this);
        //outdent();
        //println();
    }


    public void visitLibraryClass(LibraryClass libraryClass)
    {
        println("_____________________________________________________________________");
        println(visitorInfo(libraryClass) + " " +
                "Library class: " + libraryClass.getName());
        indent();
        println("Superclass:    " + libraryClass.getSuperName());
        println("Access flags:  0x" + Integer.toHexString(libraryClass.u2accessFlags));
        println("  = " +
                ((libraryClass.u2accessFlags & ClassConstants.ACC_ANNOTATTION) != 0 ? "@ " : "") +
                ClassUtil.externalClassAccessFlags(libraryClass.u2accessFlags) +
                ((libraryClass.u2accessFlags & ClassConstants.ACC_ENUM)      != 0 ? "enum " :
                 (libraryClass.u2accessFlags & ClassConstants.ACC_INTERFACE) == 0 ? "class " :
                                                                                             "") +
                ClassUtil.externalClassName(libraryClass.getName()) +
                (libraryClass.getSuperName() == null ? "" : " extends "  +
                ClassUtil.externalClassName(libraryClass.getSuperName())));
        outdent();
        println();

        println("Interfaces (count = " + libraryClass.interfaceClasses.length + "):");
        for (int index = 0; index < libraryClass.interfaceClasses.length; index++)
        {
            Clazz interfaceClass = libraryClass.interfaceClasses[index];
            if (interfaceClass != null)
            {
                println("  + " + interfaceClass.getName());
            }
        }

        println("Fields (count = " + libraryClass.fields.length + "):");
        libraryClass.fieldsAccept(this);

        println("Methods (count = " + libraryClass.methods.length + "):");
        libraryClass.methodsAccept(this);
    }


    // Implementations for ConstantVisitor.

    public void visitIntegerConstant(Clazz clazz, IntegerConstant integerConstant)
    {
        println(visitorInfo(integerConstant) + " Integer [" +
                integerConstant.getValue() + "]");
    }


    public void visitLongConstant(Clazz clazz, LongConstant longConstant)
    {
        println(visitorInfo(longConstant) + " Long [" +
                longConstant.getValue() + "]");
    }


    public void visitFloatConstant(Clazz clazz, FloatConstant floatConstant)
    {
        println(visitorInfo(floatConstant) + " Float [" +
                floatConstant.getValue() + "]");
    }


    public void visitDoubleConstant(Clazz clazz, DoubleConstant doubleConstant)
    {
        println(visitorInfo(doubleConstant) + " Double [" +
                doubleConstant.getValue() + "]");
    }


    public void visitStringConstant(Clazz clazz, StringConstant stringConstant)
    {
        println(visitorInfo(stringConstant) + " String [" +
                stringConstant.getString(clazz) + "]");
    }


    public void visitUtf8Constant(Clazz clazz, Utf8Constant utf8Constant)
    {
        println(visitorInfo(utf8Constant) + " Utf8 [" +
                utf8Constant.getString() + "]");
    }


    public void visitInvokeDynamicConstant(Clazz clazz, InvokeDynamicConstant invokeDynamicConstant)
    {
        println(visitorInfo(invokeDynamicConstant) + " InvokeDynamic [bootstrap method index = " + invokeDynamicConstant.u2bootstrapMethodAttributeIndex + "]:");

        indent();
        clazz.constantPoolEntryAccept(invokeDynamicConstant.u2nameAndTypeIndex, this);
        outdent();
    }


    public void visitMethodHandleConstant(Clazz clazz, MethodHandleConstant methodHandleConstant)
    {
        println(visitorInfo(methodHandleConstant) + " MethodHandle [kind = " + methodHandleConstant.u1referenceKind + "]:");

        indent();
        clazz.constantPoolEntryAccept(methodHandleConstant.u2referenceIndex, this);
        outdent();
    }


    public void visitFieldrefConstant(Clazz clazz, FieldrefConstant fieldrefConstant)
    {
        println(visitorInfo(fieldrefConstant) + " Fieldref [" +
                clazz.getClassName(fieldrefConstant.u2classIndex) + "." +
                clazz.getName(fieldrefConstant.u2nameAndTypeIndex) + " " +
                clazz.getType(fieldrefConstant.u2nameAndTypeIndex) + "]");
    }


    public void visitInterfaceMethodrefConstant(Clazz clazz, InterfaceMethodrefConstant interfaceMethodrefConstant)
    {
        println(visitorInfo(interfaceMethodrefConstant) + " InterfaceMethodref [" +
                clazz.getClassName(interfaceMethodrefConstant.u2classIndex)  + "." +
                clazz.getName(interfaceMethodrefConstant.u2nameAndTypeIndex) + " " +
                clazz.getType(interfaceMethodrefConstant.u2nameAndTypeIndex) + "]");
    }


    public void visitMethodrefConstant(Clazz clazz, MethodrefConstant methodrefConstant)
    {
        println(visitorInfo(methodrefConstant) + " Methodref [" +
                clazz.getClassName(methodrefConstant.u2classIndex)  + "." +
                clazz.getName(methodrefConstant.u2nameAndTypeIndex) + " " +
                clazz.getType(methodrefConstant.u2nameAndTypeIndex) + "]");
    }


    public void visitClassConstant(Clazz clazz, ClassConstant classConstant)
    {
        println(visitorInfo(classConstant) + " Class [" +
                classConstant.getName(clazz) + "]");
    }


    public void visitMethodTypeConstant(Clazz clazz, MethodTypeConstant methodTypeConstant)
    {
        println(visitorInfo(methodTypeConstant) + " MethodType [" +
                methodTypeConstant.getType(clazz) + "]");
    }


    public void visitNameAndTypeConstant(Clazz clazz, NameAndTypeConstant nameAndTypeConstant)
    {
        println(visitorInfo(nameAndTypeConstant) + " NameAndType [" +
                nameAndTypeConstant.getName(clazz) + " " +
                nameAndTypeConstant.getType(clazz) + "]");
    }


    // Implementations for MemberVisitor.

    public void visitProgramField(ProgramClass programClass, ProgramField programField)
    {
        println(visitorInfo(programField) + " " +
                "Field:        " +
                programField.getName(programClass) + " " +
                programField.getDescriptor(programClass));

        indent();
        println("Access flags: 0x" + Integer.toHexString(programField.u2accessFlags));
        println("  = " +
                ClassUtil.externalFullFieldDescription(programField.u2accessFlags,
                                                       programField.getName(programClass),
                                                       programField.getDescriptor(programClass)));

        visitMember(programClass, programField);
        outdent();
    }

    //TODO
    public void visitProgramMethod(ProgramClass programClass, ProgramMethod programMethod)
    {
        println(visitorInfo(programMethod) + " " +
                "Method:       " +
                programMethod.getName(programClass) +
                programMethod.getDescriptor(programClass));

        //indent();
        //println("Access flags: 0x" + Integer.toHexString(programMethod.u2accessFlags));
        //println("  = " +
        //        ClassUtil.externalFullMethodDescription(programClass.getName(),
        //                                                programMethod.u2accessFlags,
        //                                                programMethod.getName(programClass),
        //                                                programMethod.getDescriptor(programClass)));

        visitMember(programClass, programMethod);
        outdent();
    }


    private void visitMember(ProgramClass programClass, ProgramMember programMember)
    {
        //if (programMember.u2attributesCount > 0)
        //{
        //    println("Class member attributes (count = " + programMember.u2attributesCount + "):");
        //    programMember.attributesAccept(programClass, this);
        //}
    }


    public void visitLibraryField(LibraryClass libraryClass, LibraryField libraryField)
    {
        println(visitorInfo(libraryField) + " " +
                "Field:        " +
                libraryField.getName(libraryClass) + " " +
                libraryField.getDescriptor(libraryClass));

        indent();
        println("Access flags: 0x" + Integer.toHexString(libraryField.u2accessFlags));
        println("  = " +
                ClassUtil.externalFullFieldDescription(libraryField.u2accessFlags,
                                                       libraryField.getName(libraryClass),
                                                       libraryField.getDescriptor(libraryClass)));
        outdent();
    }


    public void visitLibraryMethod(LibraryClass libraryClass, LibraryMethod libraryMethod)
    {
        //println(visitorInfo(libraryMethod) + " " +
        //        "Method:       " +
        //        libraryMethod.getName(libraryClass) + " " +
        //        libraryMethod.getDescriptor(libraryClass));
        //
        //indent();
        //println("Access flags: 0x" + Integer.toHexString(libraryMethod.u2accessFlags));
        //println("  = " +
        //        ClassUtil.externalFullMethodDescription(libraryClass.getName(),
        //                                                libraryMethod.u2accessFlags,
        //                                                libraryMethod.getName(libraryClass),
        //                                                libraryMethod.getDescriptor(libraryClass)));
        //outdent();
    }


    // Implementations for AttributeVisitor.
    // Note that attributes are typically only referenced once, so we don't
    // test if they are marked already.

    public void visitUnknownAttribute(Clazz clazz, UnknownAttribute unknownAttribute)
    {
        println(visitorInfo(unknownAttribute) +
                " Unknown attribute (" + unknownAttribute.getAttributeName(clazz) + ")");
    }


    public void visitBootstrapMethodsAttribute(Clazz clazz, BootstrapMethodsAttribute bootstrapMethodsAttribute)
    {
        println(visitorInfo(bootstrapMethodsAttribute) +
                " Bootstrap methods attribute (count = " + bootstrapMethodsAttribute.u2bootstrapMethodsCount + "):");

        indent();
        bootstrapMethodsAttribute.bootstrapMethodEntriesAccept(clazz, this);
        outdent();
    }


    public void visitSourceFileAttribute(Clazz clazz, SourceFileAttribute sourceFileAttribute)
    {
        println(visitorInfo(sourceFileAttribute) +
                " Source file attribute:");

        indent();
        clazz.constantPoolEntryAccept(sourceFileAttribute.u2sourceFileIndex, this);
        outdent();
    }


    public void visitSourceDirAttribute(Clazz clazz, SourceDirAttribute sourceDirAttribute)
    {
        println(visitorInfo(sourceDirAttribute) +
                " Source dir attribute:");

        indent();
        clazz.constantPoolEntryAccept(sourceDirAttribute.u2sourceDirIndex, this);
        outdent();
    }


    public void visitInnerClassesAttribute(Clazz clazz, InnerClassesAttribute innerClassesAttribute)
    {
        println(visitorInfo(innerClassesAttribute) +
                " Inner classes attribute (count = " + innerClassesAttribute.u2classesCount + ")");

        indent();
        innerClassesAttribute.innerClassEntriesAccept(clazz, this);
        outdent();
    }


    public void visitEnclosingMethodAttribute(Clazz clazz, EnclosingMethodAttribute enclosingMethodAttribute)
    {
        println(visitorInfo(enclosingMethodAttribute) +
                " Enclosing method attribute:");

        indent();
        clazz.constantPoolEntryAccept(enclosingMethodAttribute.u2classIndex, this);

        if (enclosingMethodAttribute.u2nameAndTypeIndex != 0)
        {
            clazz.constantPoolEntryAccept(enclosingMethodAttribute.u2nameAndTypeIndex, this);
        }
        outdent();
    }


    public void visitDeprecatedAttribute(Clazz clazz, DeprecatedAttribute deprecatedAttribute)
    {
        println(visitorInfo(deprecatedAttribute) +
                " Deprecated attribute");
    }


    public void visitSyntheticAttribute(Clazz clazz, SyntheticAttribute syntheticAttribute)
    {
        println(visitorInfo(syntheticAttribute) +
                " Synthetic attribute");
    }


    public void visitSignatureAttribute(Clazz clazz, SignatureAttribute signatureAttribute)
    {
        println(visitorInfo(signatureAttribute) +
                " Signature attribute:");

        indent();
        clazz.constantPoolEntryAccept(signatureAttribute.u2signatureIndex, this);
        outdent();
    }


    public void visitConstantValueAttribute(Clazz clazz, Field field, ConstantValueAttribute constantValueAttribute)
    {
        println(visitorInfo(constantValueAttribute) +
                " Constant value attribute:");

        clazz.constantPoolEntryAccept(constantValueAttribute.u2constantValueIndex, this);
    }


    public void visitMethodParametersAttribute(Clazz clazz, Method method, MethodParametersAttribute methodParametersAttribute)
    {
        println(visitorInfo(methodParametersAttribute) +
                " Method parameters attribute (count = " + methodParametersAttribute.u1parametersCount + ")");

        indent();
        methodParametersAttribute.parametersAccept(clazz, method, this);
        outdent();
    }


    public void visitExceptionsAttribute(Clazz clazz, Method method, ExceptionsAttribute exceptionsAttribute)
    {
        println(visitorInfo(exceptionsAttribute) +
                " Exceptions attribute (count = " + exceptionsAttribute.u2exceptionIndexTableLength + ")");

        indent();
        exceptionsAttribute.exceptionEntriesAccept((ProgramClass)clazz, this);
        outdent();
    }


    public void visitCodeAttribute(Clazz clazz, Method method, CodeAttribute codeAttribute)
    {
        println(visitorInfo(codeAttribute) +
                " Code attribute instructions (code length = "+ codeAttribute.u4codeLength +
                ", locals = "+ codeAttribute.u2maxLocals +
                ", stack = "+ codeAttribute.u2maxStack + "):");

        indent();

        codeAttribute.instructionsAccept(clazz, method, this);

        println("Code attribute exceptions (count = " +
                codeAttribute.u2exceptionTableLength + "):");

        codeAttribute.exceptionsAccept(clazz, method, this);

        println("Code attribute attributes (attribute count = " +
                codeAttribute.u2attributesCount + "):");

        codeAttribute.attributesAccept(clazz, method, this);

        outdent();
    }


    public void visitStackMapAttribute(Clazz clazz, Method method, CodeAttribute codeAttribute, StackMapAttribute stackMapAttribute)
    {
        println(visitorInfo(codeAttribute) +
                " Stack map attribute (count = "+
                stackMapAttribute.u2stackMapFramesCount + "):");

        indent();
        stackMapAttribute.stackMapFramesAccept(clazz, method, codeAttribute, this);
        outdent();
    }


    public void visitStackMapTableAttribute(Clazz clazz, Method method, CodeAttribute codeAttribute, StackMapTableAttribute stackMapTableAttribute)
    {
        println(visitorInfo(codeAttribute) +
                " Stack map table attribute (count = "+
                stackMapTableAttribute.u2stackMapFramesCount + "):");

        indent();
        stackMapTableAttribute.stackMapFramesAccept(clazz, method, codeAttribute, this);
        outdent();
    }


    public void visitLineNumberTableAttribute(Clazz clazz, Method method, CodeAttribute codeAttribute, LineNumberTableAttribute lineNumberTableAttribute)
    {
        println(visitorInfo(lineNumberTableAttribute) +
                " Line number table attribute (count = " +
                lineNumberTableAttribute.u2lineNumberTableLength + ")");

        indent();
        lineNumberTableAttribute.lineNumbersAccept(clazz, method, codeAttribute, this);
        outdent();
    }


    public void visitLocalVariableTableAttribute(Clazz clazz, Method method, CodeAttribute codeAttribute, LocalVariableTableAttribute localVariableTableAttribute)
    {
        println(visitorInfo(localVariableTableAttribute) +
                " Local variable table attribute (count = " +
                localVariableTableAttribute.u2localVariableTableLength + ")");

        indent();
        localVariableTableAttribute.localVariablesAccept(clazz, method, codeAttribute, this);
        outdent();
    }


    public void visitLocalVariableTypeTableAttribute(Clazz clazz, Method method, CodeAttribute codeAttribute, LocalVariableTypeTableAttribute localVariableTypeTableAttribute)
    {
        println(visitorInfo(localVariableTypeTableAttribute) +
                " Local variable type table attribute (count = "+
                localVariableTypeTableAttribute.u2localVariableTypeTableLength + ")");

        indent();
        localVariableTypeTableAttribute.localVariablesAccept(clazz, method, codeAttribute, this);
        outdent();
    }


    public void visitRuntimeVisibleAnnotationsAttribute(Clazz clazz, RuntimeVisibleAnnotationsAttribute runtimeVisibleAnnotationsAttribute)
    {
        println(visitorInfo(runtimeVisibleAnnotationsAttribute) +
                " Runtime visible annotations attribute:");

        indent();
        runtimeVisibleAnnotationsAttribute.annotationsAccept(clazz, this);
        outdent();
    }


    public void visitRuntimeInvisibleAnnotationsAttribute(Clazz clazz, RuntimeInvisibleAnnotationsAttribute runtimeInvisibleAnnotationsAttribute)
    {
        println(visitorInfo(runtimeInvisibleAnnotationsAttribute) +
                " Runtime invisible annotations attribute:");

        indent();
        runtimeInvisibleAnnotationsAttribute.annotationsAccept(clazz, this);
        outdent();
    }


    public void visitRuntimeVisibleParameterAnnotationsAttribute(Clazz clazz, Method method, RuntimeVisibleParameterAnnotationsAttribute runtimeVisibleParameterAnnotationsAttribute)
    {
        println(visitorInfo(runtimeVisibleParameterAnnotationsAttribute) +
                " Runtime visible parameter annotations attribute (parameter count = " + runtimeVisibleParameterAnnotationsAttribute.u1parametersCount + "):");

        indent();
        runtimeVisibleParameterAnnotationsAttribute.annotationsAccept(clazz, method, this);
        outdent();
    }


    public void visitRuntimeInvisibleParameterAnnotationsAttribute(Clazz clazz, Method method, RuntimeInvisibleParameterAnnotationsAttribute runtimeInvisibleParameterAnnotationsAttribute)
    {
        println(visitorInfo(runtimeInvisibleParameterAnnotationsAttribute) +
                " Runtime invisible parameter annotations attribute (parameter count = " + runtimeInvisibleParameterAnnotationsAttribute.u1parametersCount + "):");

        indent();
        runtimeInvisibleParameterAnnotationsAttribute.annotationsAccept(clazz, method, this);
        outdent();
    }


    public void visitRuntimeVisibleTypeAnnotationsAttribute(Clazz clazz, RuntimeVisibleTypeAnnotationsAttribute runtimeVisibleTypeAnnotationsAttribute)
    {
        println(visitorInfo(runtimeVisibleTypeAnnotationsAttribute) +
                " Runtime visible type annotations attribute");

        indent();
        runtimeVisibleTypeAnnotationsAttribute.typeAnnotationsAccept(clazz, this);
        outdent();
    }


    public void visitRuntimeInvisibleTypeAnnotationsAttribute(Clazz clazz, RuntimeInvisibleTypeAnnotationsAttribute runtimeInvisibleTypeAnnotationsAttribute)
    {
        println(visitorInfo(runtimeInvisibleTypeAnnotationsAttribute) +
                " Runtime invisible type annotations attribute");

        indent();
        runtimeInvisibleTypeAnnotationsAttribute.typeAnnotationsAccept(clazz, this);
        outdent();
    }


    public void visitAnnotationDefaultAttribute(Clazz clazz, Method method, AnnotationDefaultAttribute annotationDefaultAttribute)
    {
        println(visitorInfo(annotationDefaultAttribute) +
                " Annotation default attribute:");

        indent();
        annotationDefaultAttribute.defaultValueAccept(clazz, this);
        outdent();
    }


    // Implementations for BootstrapMethodInfoVisitor.

    public void visitBootstrapMethodInfo(Clazz clazz, BootstrapMethodInfo bootstrapMethodInfo)
    {
        println(visitorInfo(bootstrapMethodInfo) +
                " BootstrapMethodInfo (argument count = " +
                bootstrapMethodInfo.u2methodArgumentCount+ "):");

        indent();
        clazz.constantPoolEntryAccept(bootstrapMethodInfo.u2methodHandleIndex, this);
        bootstrapMethodInfo.methodArgumentsAccept(clazz, this);
        outdent();
    }


    // Implementations for InnerClassesInfoVisitor.

    public void visitInnerClassesInfo(Clazz clazz, InnerClassesInfo innerClassesInfo)
    {
        //println(visitorInfo(innerClassesInfo) +
        //        " InnerClassesInfo:");
        //
        //indent();
        //println("Access flags:  0x" + Integer.toHexString(innerClassesInfo.u2innerClassAccessFlags) + " = " +
        //        ClassUtil.externalClassAccessFlags(innerClassesInfo.u2innerClassAccessFlags));
        //innerClassesInfo.innerClassConstantAccept(clazz, this);
        //innerClassesInfo.outerClassConstantAccept(clazz, this);
        //innerClassesInfo.innerNameConstantAccept(clazz, this);
        //outdent();
    }


    // Implementations for InstructionVisitor.

    public void visitAnyInstruction(Clazz clazz, Method method, CodeAttribute codeAttribute, int offset, Instruction instruction)
    {
        println(instruction.toString(offset));
    }


    public void visitConstantInstruction(Clazz clazz, Method method, CodeAttribute codeAttribute, int offset, ConstantInstruction constantInstruction)
    {
        println(constantInstruction.toString(offset));

        indent();
        clazz.constantPoolEntryAccept(constantInstruction.constantIndex, this);
        outdent();
    }


    public void visitTableSwitchInstruction(Clazz clazz, Method method, CodeAttribute codeAttribute, int offset, TableSwitchInstruction tableSwitchInstruction)
    {
        println(tableSwitchInstruction.toString(offset));

        indent();

        int[] jumpOffsets = tableSwitchInstruction.jumpOffsets;

        for (int index = 0; index < jumpOffsets.length; index++)
        {
            int jumpOffset = jumpOffsets[index];
            println(Integer.toString(tableSwitchInstruction.lowCase + index)  + ": offset = " + jumpOffset + ", target = " + (offset + jumpOffset));
        }

        int defaultOffset = tableSwitchInstruction.defaultOffset;
        println("default: offset = " + defaultOffset + ", target = "+ (offset + defaultOffset));

        outdent();
    }


    public void visitLookUpSwitchInstruction(Clazz clazz, Method method, CodeAttribute codeAttribute, int offset, LookUpSwitchInstruction lookUpSwitchInstruction)
    {
        println(lookUpSwitchInstruction.toString(offset));

        indent();

        int[] cases       = lookUpSwitchInstruction.cases;
        int[] jumpOffsets = lookUpSwitchInstruction.jumpOffsets;

        for (int index = 0; index < jumpOffsets.length; index++)
        {
            int jumpOffset = jumpOffsets[index];
            println(Integer.toString(cases[index])  + ": offset = " + jumpOffset + ", target = " + (offset + jumpOffset));
        }

        int defaultOffset = lookUpSwitchInstruction.defaultOffset;
        println("default: offset = " + defaultOffset + ", target = "+ (offset + defaultOffset));

        outdent();
    }


    // Implementations for ExceptionInfoVisitor.

    public void visitExceptionInfo(Clazz clazz, Method method, CodeAttribute codeAttribute, ExceptionInfo exceptionInfo)
    {
        println(visitorInfo(exceptionInfo) +
                " ExceptionInfo (" +
                exceptionInfo.u2startPC + " -> " +
                exceptionInfo.u2endPC + ": " +
                exceptionInfo.u2handlerPC + "):");

        if (exceptionInfo.u2catchType != 0)
        {
            clazz.constantPoolEntryAccept(exceptionInfo.u2catchType, this);
        }
    }


    // Implementations for StackMapFrameVisitor.

    public void visitSameZeroFrame(Clazz clazz, Method method, CodeAttribute codeAttribute, int offset, SameZeroFrame sameZeroFrame)
    {
        println(visitorInfo(sameZeroFrame) +
                " [" + offset  + "]" +
                " Var: ..., Stack: (empty)");
    }


    public void visitSameOneFrame(Clazz clazz, Method method, CodeAttribute codeAttribute, int offset, SameOneFrame sameOneFrame)
    {
        print(visitorInfo(sameOneFrame) +
              " [" + offset  + "]" +
              " Var: ..., Stack: ");

        sameOneFrame.stackItemAccept(clazz, method, codeAttribute, offset, this);

        println();
    }


    public void visitLessZeroFrame(Clazz clazz, Method method, CodeAttribute codeAttribute, int offset, LessZeroFrame lessZeroFrame)
    {
        println(visitorInfo(lessZeroFrame) +
                " [" + offset  + "]" +
                " Var: -" + lessZeroFrame.choppedVariablesCount +
                ", Stack: (empty)");
    }


    public void visitMoreZeroFrame(Clazz clazz, Method method, CodeAttribute codeAttribute, int offset, MoreZeroFrame moreZeroFrame)
    {
        print(visitorInfo(moreZeroFrame) +
              " [" + offset  + "]" +
              " Var: ...");

        moreZeroFrame.additionalVariablesAccept(clazz, method, codeAttribute, offset, this);

        ps.println(", Stack: (empty)");
    }


    public void visitFullFrame(Clazz clazz, Method method, CodeAttribute codeAttribute, int offset, FullFrame fullFrame)
    {
        print(visitorInfo(fullFrame) +
              " [" + offset  + "]" +
              " Var: ");

        fullFrame.variablesAccept(clazz, method, codeAttribute, offset, this);

        ps.print(", Stack: ");

        fullFrame.stackAccept(clazz, method, codeAttribute, offset, this);

        println();
    }


    // Implementations for VerificationTypeVisitor.

    public void visitIntegerType(Clazz clazz, Method method, CodeAttribute codeAttribute, int offset, IntegerType integerType)
    {
        ps.print("[i]");
    }


    public void visitFloatType(Clazz clazz, Method method, CodeAttribute codeAttribute, int offset, FloatType floatType)
    {
        ps.print("[f]");
    }


    public void visitLongType(Clazz clazz, Method method, CodeAttribute codeAttribute, int offset, LongType longType)
    {
        ps.print("[l]");
    }


    public void visitDoubleType(Clazz clazz, Method method, CodeAttribute codeAttribute, int offset, DoubleType doubleType)
    {
        ps.print("[d]");
    }


    public void visitTopType(Clazz clazz, Method method, CodeAttribute codeAttribute, int offset, TopType topType)
    {
        ps.print("[T]");
    }


    public void visitObjectType(Clazz clazz, Method method, CodeAttribute codeAttribute, int offset, ObjectType objectType)
    {
        ps.print("[a:" + clazz.getClassName(objectType.u2classIndex) + "]");
    }


    public void visitNullType(Clazz clazz, Method method, CodeAttribute codeAttribute, int offset, NullType nullType)
    {
        ps.print("[n]");
    }


    public void visitUninitializedType(Clazz clazz, Method method, CodeAttribute codeAttribute, int offset, UninitializedType uninitializedType)
    {
        ps.print("[u:" + uninitializedType.u2newInstructionOffset + "]");
    }


    public void visitUninitializedThisType(Clazz clazz, Method method, CodeAttribute codeAttribute, int offset, UninitializedThisType uninitializedThisType)
    {
        ps.print("[u:this]");
    }


    // Implementations for LineNumberInfoVisitor.

    public void visitLineNumberInfo(Clazz clazz, Method method, CodeAttribute codeAttribute, LineNumberInfo lineNumberInfo)
    {
        println("[" + lineNumberInfo.u2startPC + "] -> line " +
                lineNumberInfo.u2lineNumber +
                (lineNumberInfo.getSource() == null ? "" : " [" + lineNumberInfo.getSource() + "]"));
    }


    // Implementations for ParameterInfoVisitor.

    public void visitParameterInfo(Clazz clazz, Method method, int parameterIndex, ParameterInfo parameterInfo)
    {
        //println("p" + parameterIndex + ": access flags: 0x" + Integer.toHexString(parameterInfo.u2accessFlags) + " = " +
        //        ClassUtil.externalParameterAccessFlags(parameterInfo.u2accessFlags) +
        //        (parameterInfo.u2nameIndex == 0 ? "" : " [" + parameterInfo.getName(clazz) + "]"));
    }


    // Implementations for LocalVariableInfoVisitor.

    public void visitLocalVariableInfo(Clazz clazz, Method method, CodeAttribute codeAttribute, LocalVariableInfo localVariableInfo)
    {
        println("v" + localVariableInfo.u2index + ": " +
                localVariableInfo.u2startPC + " -> " +
                (localVariableInfo.u2startPC + localVariableInfo.u2length) + " [" +
                localVariableInfo.getDescriptor(clazz) + " " +
                localVariableInfo.getName(clazz) + "]");
    }


    // Implementations for LocalVariableTypeInfoVisitor.

    public void visitLocalVariableTypeInfo(Clazz clazz, Method method, CodeAttribute codeAttribute, LocalVariableTypeInfo localVariableTypeInfo)
    {
        println("v" + localVariableTypeInfo.u2index + ": " +
                localVariableTypeInfo.u2startPC + " -> " +
                (localVariableTypeInfo.u2startPC + localVariableTypeInfo.u2length) + " [" +
                localVariableTypeInfo.getSignature(clazz) + " " +
                localVariableTypeInfo.getName(clazz) + "]");
    }


    // Implementations for AnnotationVisitor.

    public void visitAnnotation(Clazz clazz, Annotation annotation)
    {
        println(visitorInfo(annotation) +
                " Annotation [" + annotation.getType(clazz) + "]:");

        indent();
        annotation.elementValuesAccept(clazz, this);
        outdent();
    }


    // Implementations for TypeAnnotationVisitor.

    public void visitTypeAnnotation(Clazz clazz, TypeAnnotation typeAnnotation)
    {
        println(visitorInfo(typeAnnotation) +
                " Type annotation [" + typeAnnotation.getType(clazz) + "]:");

        indent();
        typeAnnotation.targetInfoAccept(clazz, this);

        println("Type path (count = " + typeAnnotation.typePath.length + "):");
        indent();
        typeAnnotation.typePathInfosAccept(clazz, this);
        outdent();

        typeAnnotation.elementValuesAccept(clazz, this);

        outdent();
    }

    // Implementations for TargetInfoVisitor.

    public void visitTypeParameterTargetInfo(Clazz clazz, TypeAnnotation typeAnnotation, TypeParameterTargetInfo typeParameterTargetInfo)
    {
        println("Target (type = 0x" + Integer.toHexString(typeParameterTargetInfo.u1targetType) + "): Parameter #" +
                typeParameterTargetInfo.u1typeParameterIndex);
    }


    public void visitSuperTypeTargetInfo(Clazz clazz, TypeAnnotation typeAnnotation, SuperTypeTargetInfo superTypeTargetInfo)
    {
        println("Target (type = 0x" + Integer.toHexString(superTypeTargetInfo.u1targetType) + "): " +
                (superTypeTargetInfo.u2superTypeIndex == 0xffff ?
                     "super class" :
                     "interface #" + superTypeTargetInfo.u2superTypeIndex));
    }


    public void visitTypeParameterBoundTargetInfo(Clazz clazz, TypeAnnotation typeAnnotation, TypeParameterBoundTargetInfo typeParameterBoundTargetInfo)
    {
        println("Target (type = 0x" + Integer.toHexString(typeParameterBoundTargetInfo.u1targetType) + "): parameter #" +
                typeParameterBoundTargetInfo.u1typeParameterIndex + ", bound #" + typeParameterBoundTargetInfo.u1boundIndex);
    }


    public void visitEmptyTargetInfo(Clazz clazz, Member member, TypeAnnotation typeAnnotation, EmptyTargetInfo emptyTargetInfo)
    {
        println("Target (type = 0x" + Integer.toHexString(emptyTargetInfo.u1targetType) + ")");
    }


    public void visitFormalParameterTargetInfo(Clazz clazz, Method method, TypeAnnotation typeAnnotation, FormalParameterTargetInfo formalParameterTargetInfo)
    {
        println("Target (type = 0x" + Integer.toHexString(formalParameterTargetInfo.u1targetType) + "): formal parameter #" +
                formalParameterTargetInfo.u1formalParameterIndex);
    }


    public void visitThrowsTargetInfo(Clazz clazz, Method method, TypeAnnotation typeAnnotation, ThrowsTargetInfo throwsTargetInfo)
    {
        println("Target (type = 0x" + Integer.toHexString(throwsTargetInfo.u1targetType) + "): throws #" +
                throwsTargetInfo.u2throwsTypeIndex);
    }


    public void visitLocalVariableTargetInfo(Clazz clazz, Method method, CodeAttribute codeAttribute, TypeAnnotation typeAnnotation, LocalVariableTargetInfo localVariableTargetInfo)
    {
        println("Target (type = 0x" + Integer.toHexString(localVariableTargetInfo.u1targetType) + "): local variables (count = " +
                localVariableTargetInfo.u2tableLength + ")");

        indent();
        localVariableTargetInfo.targetElementsAccept(clazz, method, codeAttribute, typeAnnotation, this);
        outdent();
    }


    public void visitCatchTargetInfo(Clazz clazz, Method method, CodeAttribute codeAttribute, TypeAnnotation typeAnnotation, CatchTargetInfo catchTargetInfo)
    {
        println("Target (type = 0x" + Integer.toHexString(catchTargetInfo.u1targetType) + "): catch #" +
                catchTargetInfo.u2exceptionTableIndex);
    }


    public void visitOffsetTargetInfo(Clazz clazz, Method method, CodeAttribute codeAttribute, TypeAnnotation typeAnnotation, OffsetTargetInfo offsetTargetInfo)
    {
        println("Target (type = 0x" + Integer.toHexString(offsetTargetInfo.u1targetType) + "): offset " +
                offsetTargetInfo.u2offset);
    }


    public void visitTypeArgumentTargetInfo(Clazz clazz, Method method, CodeAttribute codeAttribute, TypeAnnotation typeAnnotation, TypeArgumentTargetInfo typeArgumentTargetInfo)
    {
        println("Target (type = 0x" + Integer.toHexString(typeArgumentTargetInfo.u1targetType) + "): offset " +
                typeArgumentTargetInfo.u2offset + ", type argument " +
                typeArgumentTargetInfo.u1typeArgumentIndex);
    }


    // Implementations for TypePathInfoVisitor.

    public void visitTypePathInfo(Clazz clazz, TypeAnnotation typeAnnotation, TypePathInfo typePathInfo)
    {
        println("kind = " +
                typePathInfo.u1typePathKind + ", argument index = " +
                typePathInfo.u1typeArgumentIndex);
    }


    // Implementations for LocalVariableTargetElementVisitor.

    public void visitLocalVariableTargetElement(Clazz clazz, Method method, CodeAttribute codeAttribute, TypeAnnotation typeAnnotation, LocalVariableTargetInfo localVariableTargetInfo, LocalVariableTargetElement localVariableTargetElement)
    {
        println("v" +
                localVariableTargetElement.u2index + ": " +
                localVariableTargetElement.u2startPC + " -> " +
                (localVariableTargetElement.u2startPC + localVariableTargetElement.u2length));
    }


    // Implementations for ElementValueVisitor.

    public void visitConstantElementValue(Clazz clazz, Annotation annotation, ConstantElementValue constantElementValue)
    {
        println(visitorInfo(constantElementValue) +
                " Constant element value [" +
                (constantElementValue.u2elementNameIndex == 0 ? "(default)" :
                constantElementValue.getMethodName(clazz)) + " '" +
                constantElementValue.u1tag + "']");

        indent();
        clazz.constantPoolEntryAccept(constantElementValue.u2constantValueIndex, this);
        outdent();
    }


    public void visitEnumConstantElementValue(Clazz clazz, Annotation annotation, EnumConstantElementValue enumConstantElementValue)
    {
        println(visitorInfo(enumConstantElementValue) +
                " Enum constant element value [" +
                (enumConstantElementValue.u2elementNameIndex == 0 ? "(default)" :
                enumConstantElementValue.getMethodName(clazz)) + ", " +
                enumConstantElementValue.getTypeName(clazz)  + ", " +
                enumConstantElementValue.getConstantName(clazz) + "]");
    }


    public void visitClassElementValue(Clazz clazz, Annotation annotation, ClassElementValue classElementValue)
    {
        println(visitorInfo(classElementValue) +
                " Class element value [" +
                (classElementValue.u2elementNameIndex == 0 ? "(default)" :
                classElementValue.getMethodName(clazz)) + ", " +
                classElementValue.getClassName(clazz) + "]");
    }


    public void visitAnnotationElementValue(Clazz clazz, Annotation annotation, AnnotationElementValue annotationElementValue)
    {
        println(visitorInfo(annotationElementValue) +
                " Annotation element value [" +
                (annotationElementValue.u2elementNameIndex == 0 ? "(default)" :
                annotationElementValue.getMethodName(clazz)) + "]:");

        indent();
        annotationElementValue.annotationAccept(clazz, this);
        outdent();
    }


    public void visitArrayElementValue(Clazz clazz, Annotation annotation, ArrayElementValue arrayElementValue)
    {
        println(visitorInfo(arrayElementValue) +
                " Array element value [" +
                (arrayElementValue.u2elementNameIndex == 0 ? "(default)" :
                arrayElementValue.getMethodName(clazz)) + "]:");

        indent();
        arrayElementValue.elementValuesAccept(clazz, annotation, this);
        outdent();
    }


    // Small utility methods.

    private void indent()
    {
        indentation++;
    }

    private void outdent()
    {
        indentation--;
    }

    private void println(String string)
    {
        print(string);
        println();

    }

    private void print(String string)
    {
        for (int index = 0; index < indentation; index++)
        {
            ps.print(INDENTATION);
        }

        ps.print(string);
    }

    private void println()
    {
        ps.println();
    }


    private String visitorInfo(VisitorAccepter visitorAccepter)
    {
        return visitorAccepter.getVisitorInfo() == null ? "-" : "+";
    }
}
